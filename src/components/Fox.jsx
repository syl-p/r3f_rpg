/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 ./public/models/Fox/glTF/Fox.gltf 
*/

import {useRef, useState} from 'react'
import {useGLTF, useAnimations, useKeyboardControls} from '@react-three/drei'
import {useFrame} from "@react-three/fiber";
import * as THREE from 'three'
import useTpsCamera from "../hooks/TpsCamera.js";

export function Fox(props) {
  console.log('init fox')
  const group = useRef()
  const tpsCameraUpdate = useTpsCamera(group, new THREE.Vector3(-3.5, 5, -7.5), new THREE.Vector3(0, 5, 6))

  const { nodes, materials, animations } = useGLTF('/models/Fox/glTF/Fox.gltf')
  const { actions } = useAnimations(animations, group)
  const [, get] = useKeyboardControls()

  const runVelocity = 5
  const walkVelocity = 2
  const fadeDuration = 0.2
  const [action, setAction] = useState('Survey')

  useFrame((state, delta) => {
    tpsCameraUpdate(delta)

    // handleAnimation()
    handleMovements(delta)
  })

  const handleAnimation = () => {
    const { forward, backward, left, right, jump, run } = get()

    // animations
    const directionPressed = [forward, backward, left, right].some(key => key == true)
    let play = ''
    if (directionPressed && run) {
      play = 'Run'
    } else if(directionPressed) {
      play = 'Walk'
    } else {
      play = 'Survey'
    }

    if (action !== play) {
      const current = actions[action]
      const toPlay = actions[play]
      current?.fadeOut(fadeDuration)
      toPlay?.reset().fadeIn(fadeDuration).play()
      setAction(play)
    }
  }

  const handleMovements = (delta) => {
    const { forward, backward, left, right, jump, run } = get()

    const _Q = new THREE.Quaternion();
    const _A = new THREE.Vector3();
    const _R = group.current.quaternion.clone();

    let velocity = run ? runVelocity : walkVelocity
    if (left) {
      _A.set(0, 1, 0);
      _Q.setFromAxisAngle(
          _A,
          4.0 * Math.PI * delta * 0.5
      );
      _R.multiply(_Q);
    }
    if (right) {
      _A.set(0, 1, 0);
      _Q.setFromAxisAngle(
          _A,
          4.0 * -Math.PI * delta * 0.5
      );
      _R.multiply(_Q);
    }
    group.current.quaternion.copy(_R);


    if(forward || backward) {
      // Forward is direction z
      const forward_dir = new THREE.Vector3(0, 0, 1)
      forward_dir.applyQuaternion(group.current.quaternion); // Apply rotation
      forward_dir.normalize();
      if (backward) velocity *= -1 // invert velocity for backward
      forward_dir.multiplyScalar(velocity * delta); // Apply velocity on z axe
      group.current.position.add(forward_dir)
    }
  }

  return (
    <group ref={group} {...props} dispose={null}>
      <group>
        <group name="root">
          <primitive object={nodes._rootJoint} />
          <skinnedMesh castShadow receiveShadow name="fox" geometry={nodes.fox.geometry} material={materials.fox_material} skeleton={nodes.fox.skeleton} />
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/models/Fox/glTF/Fox.gltf')
